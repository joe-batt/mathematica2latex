package de.tud.mathematica2latex;

import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.util.Arrays;
import java.util.HashMap;
import java.util.Set;

public class Splitter {

	private static final String BASE = "base";
	private String currentModule;
	private File inc=new File("includes");
	private File currentFile;
	private File currentDir;
	private int currentTabWidth;
	private int openBraces=0;
	private boolean extraIndent=false;
	private boolean isStarted=false;
	private StringBuilder baseKeyWords=new StringBuilder();
	private StringBuilder helperKeyWords=new StringBuilder();
	
	private char escapeChar;
	private String topLayer;
	private String bottomLayer;
	
	/**
	 * charMappings contains the mapping data from <i>Mathematica</i> special characters
	 * to the LaTeX version. Currently only greek letters are included. It is generated by
	 * readMappings
	 */
	private HashMap<String, String> charMappings=new HashMap<String, String>();
	
	/**
	 * This function reads the mappings from the selected file and inserts them into charMappings
	 * @param mappings the file containing the mappings
	 */
	private void readMappings(File mappings){
		try {
			FileReader r=new FileReader(mappings);
			BufferedReader br=new BufferedReader(r);
			String line=br.readLine();
			while(line!=null){
				if(!line.trim().equals("") && !line.startsWith("#")){
					if(line.contains("=")){
						String[] split=line.split("=", 2);
						charMappings.put(split[0], split[1]);
					}
					else System.out.println("WARNING: No Valid Entry!");
				}
				line=br.readLine();
			}
			br.close();
		} catch (FileNotFoundException e) {
			System.out.println("ERROR: Mappings File Not Found!");
		} catch (IOException e) {
			System.out.println("ERROR: Mappings File Could Not Be Read!");
		}
	}

	/**
	 * The generic constructor for Splitter
	 * @param escapeChar the escapeChar used by the listings package
	 * @param topLayer the name of the top hierarchical layer used for module heading, e.g. "section"  
	 * @param bottomLayer the lower layer used for the helper functions heading, e.g. "subsection*"
	 */
	public Splitter(char escapeChar, String topLayer, String bottomLayer){
		this.escapeChar=escapeChar;
		this.topLayer=topLayer;
		this.bottomLayer=bottomLayer;
	}
	
	/**
	 * This constructor predefines the escapeChar as '~', topLayer as "subsection" and
	 * bottomLayer as "subsubsection*"
	 */
	public Splitter(){
		this('~',"subsection","subsubsection*");
	}
	
	/**
	 * Split the selected <i>Mathematica</i> file into smaller pieces with proper
	 * indentation and LaTeX interpreted greek letters.
	 * @param f the <i>Mathematica</i> notebook saved as text file
	 */
	public void split(File f){
		try {
			System.out.println("Reading Mathematica File");
			FileReader r=new FileReader(f);
			BufferedReader br=new BufferedReader(r);
			StringBuilder sb=new StringBuilder();
			String line=br.readLine();
			
			// continue while there are still lines left
			while(line!=null){
				
				// if a block was started and the (*end*) tag appears, end block
				// and write the file
				if(line.trim().equals("(*end*)") && isStarted){
					writeCurrentFile(sb);
					isStarted=false;
				}
				
				// else check for start of a block, remove "In[21]:=" style nonsense Mathematica might have added
				// and heading/trailing spaces
				else{line=line.replaceAll("^In\\[[0-9]+\\]:=", "").trim();
					if(line.startsWith("(*helper: ") || line.startsWith("(*module: ") || line.trim().equals("(*base*)")){	
						
						// start a new StringBuilder, reset indentation and number of open braces
						// just in case they were not recognizes correctly in the last module
						sb=new StringBuilder();
						currentTabWidth=0;
						openBraces=0;
						extraIndent=false;
						isStarted=true;
						
						// if it's a helper block use the includes/moduleName/helper file,
						// for a module block use the includes/moduleName/module file
						// and for the base block the includes/base/base file is used.
						if(line.startsWith("(*helper: ")){
							currentModule=line.replace("(*helper: ", "").replace("*)", "").trim();
							currentDir=new File("includes/"+currentModule);
							currentFile=new File("includes/"+currentModule+"/helper");
						}else if(line.startsWith("(*module: ")){
							currentModule=line.replace("(*module: ", "").replace("*)", "").trim();
							currentDir=new File("includes/"+currentModule);
							currentFile=new File("includes/"+currentModule+"/module");
						}
						else{
							currentModule=BASE;
							currentDir=new File("includes/base");
							currentFile=new File("includes/base/base");
						}
						
					}
					else{
						//add the indented line to the current StringBuilder but only if we are in a valid block
						if(isStarted) sb.append(indent(line));
					}
					line=br.readLine();
				}
			}
			br.close();
			r.close();
			buildLaTeXFile();
		} catch (FileNotFoundException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
	}

	/**
	 * Write the content of the selected StringBuilder into the current file, create
	 * all directories that may be missing
	 * @param sb the content of the file to write
	 */
	private void writeCurrentFile(StringBuilder sb) {
		try {
			System.out.println("Writing file "+currentFile.getPath());
			if(!currentDir.exists()) currentDir.mkdirs();
			FileWriter w=new FileWriter(currentFile);
			if(sb.toString().trim().startsWith("\n")){
				System.out.println("EMPTY LINE!");
			}
			w.append(sb.toString().trim());
			w.close();
		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		
	}
	
	/**
	 * Count the number of open braces in line, add the value to openBraces
	 * @param line
	 * @return
	 */
	private int countBraces(String line){
		char[] chars=line.toCharArray();
		int count=0;
		for(char c: chars){
			if(c=='[') count++;
			if(c==']') count--;
		}
		openBraces+=count;
		return count;
	}
	
	/**
	 * Use proper indentation for the current line
	 * @param line
	 * @return
	 */
	private String indent(String line){
		line=line.trim();
		int count=countBraces(line);
		int indent=0;
		StringBuilder tmp=new StringBuilder();
		
		// If at least one brace opened within the line
		// indent all following lines by one additional
		// step, e.g. an opening "If" will not be indented
		// but it's content
		// If more braces closed than opened remove indentation
		// steps immediately
		if(count>=0) indent=currentTabWidth;
		if(count<0) indent=currentTabWidth+count;
		currentTabWidth+=count;
		
		// indent the line by adding tabs and the beginning of it
		for(int i=1;i<=indent;i++){
			tmp.append("\t");
		}
		
		// if an extra indentation is requested, insert it as well, it's no full indentation step
		if(extraIndent){
			extraIndent=false;
			tmp.append("  ");
		}
		
		//If the line neither ends with a ';', ']', '*)', ',', is empty or starts with '(*' use the extra indent for the next line.
		if(!line.endsWith(";") && !line.endsWith("]") && !line.trim().equals("") && !line.trim().endsWith(",") && !line.trim().startsWith("(*") && !line.trim().endsWith("*)")) extraIndent=true;
		
		//Append the actual string behind the indentation but replace all special character before doing so
		tmp.append(InsertSpecialCharacter(line));
		
		// If no braces are currently open the current function must be at an end,
		// just in case something went wrong reset tabwith and extra indentation
		if(openBraces==0){
			currentTabWidth=0;
			extraIndent=false;
		}
		
		// extract extra keywords for source highlighting if we are in a non-module block
		if(currentModule.equals(BASE)){
			extractKeyWord(line, true);
		} else if(currentFile.getName().equals("helper")){
			extractKeyWord(line,false);
		}
		return tmp.toString()+"\n";
	}
	
	/**
	 * This function replaces <i>Mathematica</i>'s \[<i>name</i>] with the LaTeX equivalent,
	 * e.g. \[Pi] is converted to $\\pi$ with escapeChars wrapped around. Currently this only works
	 * for greek letters. All other special characters stay as they are. 
	 * @param line the string possibly containing special characters.
	 * @return the string with all special character occurences replaced 
	 */
	private String InsertSpecialCharacter(String line) {
		
		// Continue while line contains constructs of the form \[letters]
		while(line.matches(".*\\\\\\[[A-Za-z]+\\].*")){
			
			// Get the indices of the start and end of a character code
			int start=line.indexOf("\\[");
			int end=line.indexOf("]",start);
			
			// ensure that the closing "]" stand after the opening "\["
			while(line.indexOf("\\[",start+2)<end && line.indexOf("\\[",start+2)!=-1){
				start=line.indexOf("\\[",start+2);
			}
			
			// Get the replacement from charMappings and replace the occurence. 
			// If no replacement is defined, do nothing
			String rep=charMappings.get(line.substring(start+2,end));
			if(rep!=null){
				rep=escapeChar+"$"+rep+"$"+escapeChar;
				String str=line.substring(start,end+1);
				line=line.replace(str, rep);
			}	
		}
		return line;
	}

	/**
	 * This function extracts keywords from the <i>Mathematica</i> source code, they are
	 * highlighted depending on the type.
	 * @param line the line probalby containing the keyword
	 * @param isBase defines if it's a helper or the base block
	 */
	private void extractKeyWord(String line, boolean isBase) {
		int pos=-1;
		StringBuilder sb=null;
		
		// for the base block every standing left of a '=' is used as keyword 
		if(isBase){
			pos=line.indexOf("=")+1;
			sb=baseKeyWords;
		}
		
		// if it's a helper use everything standing left of ":= Module" or ":=Module" is used
		// as keyword. If neither of these is the case use function headers, e.g. "f[x_]:=" stand
		// in a line by themself, use the function name as keyword.
		else{
			sb=helperKeyWords;
			pos=line.indexOf(":= Module");
			if(pos==-1) pos=line.indexOf(":=Module");
			if(pos==-1 && line.trim().matches("[A-Za-z]*\\[.*\\][ ]?:=")) pos=line.indexOf(":=");
		}
		
		// If it's not part of a comment, use the keyword
		if(pos>0 && (!line.contains("(*") ||  !line.contains("*)"))){
			sb.append(line.substring(0, pos-1).replaceAll("\\[.*\\]?", "").replaceAll(":","").trim()+",");
		}
	}
	
	/**
	 * Build a LaTeX file that includes all generated files with surrouding structure elements.
	 */
	private void buildLaTeXFile(){
		//find all files in './includes' and sort the list alphabetically
		File[] modDirs=inc.listFiles();
		Arrays.sort(modDirs);
		StringBuilder sb=new StringBuilder();
		StringBuilder tmp=new StringBuilder();
		
		// If keywords for the base block and helpers exist, add them now
		// helper use keyword style 2, base uses keyword style 3
		// currently the actual representation (italic, bold, sans serif, etc.) is fixed
		// and can only be changed here within the source code
		if(baseKeyWords.length()>0)
			baseKeyWords.setLength(baseKeyWords.length()-1);
		if(helperKeyWords.length()>0)
			helperKeyWords.setLength(helperKeyWords.length()-1);
		tmp.append("classoffset=3,morekeywords={"+baseKeyWords.toString()+"},keywordstyle=\\itshape\\bfseries,\n");
		tmp.append("classoffset=2,morekeywords={"+helperKeyWords.toString()+"},keywordstyle=\\sffamily\\itshape,\n");
		tmp.append("classoffset=1,keywordstyle=\\scshape,\n");
		
		// for modules a different approach is used. It is assumed that modules contain
		// only a single function, aka the module, and nothing else
		// therefore it is sufficient to use the module name as keyword, since the name
		// was also used for the directory containing the parsed source code, the directory
		// name is used to get the keyword
		tmp.append("classoffset=0,morekeywords={");
		for(File f:modDirs){
			// iterate through all files but only choose those that are directories
			// and not the "base" directory, append the name to the list of keywords
			if(!f.getName().equals(BASE) && f.isDirectory())
				tmp.append(f.getName()+",");
		}
		tmp.setLength(tmp.length()-1);
		tmp.append("},\n");
		
		// add some other stuff defining the layout
		sb.append("\\lstset{language=Mathematica,\n	showlines=true,\nbasicstyle=\\small\\ttfamily,\nbreaklines=true,\n");
		sb.append("extendedchars=false, escapechar="+escapeChar+",\n");
		sb.append("numbers=left,\nnumberstyle=\\scriptsize,\nshowlines=true,\n");
		sb.append("linewidth=\\linewidth,\nstepnumber=1,\ntabsize=3,\nkeywordstyle=\\sffamily\\color{black}\\bfseries,\n");
		sb.append("stringstyle=\\ttfamily\\footnotesize\\color[gray]{.3},\nshowstringspaces=false,\n");
		sb.append("commentstyle=\\rmfamily\\itshape,\n");
		sb.append(tmp.toString()+"}\n");
		
		// now start inserting the data starting with the contents of the base block
		// a heading of the type "topLayer" is added with the name, a label is added to
		// allow referencing, also the description in the documentation is referenced.
		// Of course this requires the appropriate labels.
		sb.append("\\"+topLayer+"{Basic Definitions}\\label{src:base}\n");
		sb.append("\\hspace{2cm}\\emph{(see \\autoref{mod:base})}");
		sb.append("\\lstinputlisting{../includes/base/base}\n\n");
		
		// do the same for all modules but also add the 'bottomLayer' layer by which helper functions
		// and the actual module are separated. 
		for(File f:modDirs){
			if(f.isDirectory() && !f.getName().equals(BASE)){
				sb.append("\\"+topLayer+"{"+f.getName()+"}\\label{src:"+f.getName()+"}\n");
				sb.append("\\hspace{2cm}\\emph{(see \\autoref{mod:"+f.getName()+"})}\n");
				File[] files=f.listFiles();
				for(File file: files){
					if(file.getName().equals("helper")){
						sb.append("\\"+bottomLayer+"{Helper Functions}\n\\label{help:"+f.getName()+"}");
						sb.append("\\lstinputlisting{../"+file.getPath()+"}\n");
					}
				}
				sb.append("\\"+bottomLayer+"{Module}\n");
				sb.append("\\lstinputlisting{../"+f.getPath()+"/module}\n\n");
			}
		}
		try {
			// now write the file to ./includes/modules.tex
			FileWriter w=new FileWriter("includes/modules.tex");
			w.append(sb.toString());
			w.close();
		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
	}
	

	public static void main(String[] args) {
		Splitter s=new Splitter();
		s.readMappings(new File("./mappings"));
		s.split(new File("mathematica/Thesis.txt"));
	}
}
